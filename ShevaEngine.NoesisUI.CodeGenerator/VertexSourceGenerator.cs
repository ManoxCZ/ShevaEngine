using Microsoft.Xna.Framework.Graphics;
using Noesis;
using System;
using System.IO;

namespace ShevaEngine.NoesisUI.CodeGenerator
{
    public class VertexSourceGenerator 
    {
        public void Execute(string outputPath)
        {
            foreach (Shader.Vertex.Format.Enum item in Enum.GetValues(typeof(Shader.Vertex.Format.Enum)))
            {
                if (item == Shader.Vertex.Format.Enum.Count)
                    continue;

                string vertexTypeName = $"NoesisVertex{item}";

                string source = $@"// <auto-generated/>
using System;
﻿using System.Runtime.InteropServices;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Graphics.PackedVector;

namespace ShevaEngine.NoesisUI.Generated
{{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct {vertexTypeName} : IVertexType
    {{
        private static readonly VertexDeclaration _vertexDeclaration;
        VertexDeclaration IVertexType.VertexDeclaration => _vertexDeclaration;        

{GetFields(item.ToString())}
        static {vertexTypeName}()
		{{
			VertexElement[] elements = new VertexElement[] 
            {{ 
{GetVertexElements(item.ToString())}
            }};			
			_vertexDeclaration = new VertexDeclaration(elements);
		}}
    }}
}}
";

                File.WriteAllText(System.IO.Path.Combine(outputPath, $"{vertexTypeName}.generated.cs"), source);
            }
        }

        private string GetFields(string vertexTypeName)
        {
            string result = string.Empty;

            foreach (Shader.Vertex.Format.Attr.Enum item in Enum.GetValues(typeof(Shader.Vertex.Format.Attr.Enum)))
            {
                if (vertexTypeName.Contains(item.ToString()))
                {
                    return $"\t\tpublic {GetVertexElementFormat(Shader.TypeForAttr(item))} {item};\r\n";
                }
            }

            return result;
        }

        private string GetVertexElements(string vertexTypeName)
        {
            string result = string.Empty;
            int offset = 0;

            foreach (Shader.Vertex.Format.Attr.Enum item in Enum.GetValues(typeof(Shader.Vertex.Format.Attr.Enum)))
            {
                if (vertexTypeName.Contains(item.ToString()))
                {
                    result += $"\t\t\t\tnew VertexElement({offset}, " +
                        $"VertexElementFormat.{GetVertexElementFormat(Shader.TypeForAttr(item))}, " +
                        $"VertexElementUsage.{GetVertexElementUsage(item)}),\r\n";
                    offset += Shader.SizeForType(Shader.TypeForAttr(item));
                }
            }

            return result;
        }


        private static string GetVertexElementFormat(Shader.Vertex.Format.Attr.Type.Enum attributeType)
        {
            switch (attributeType)
            {
                case Shader.Vertex.Format.Attr.Type.Enum.Float:
                    return nameof(VertexElementFormat.Single);

                case Shader.Vertex.Format.Attr.Type.Enum.Float2:
                    return nameof(VertexElementFormat.Vector2);

                case Shader.Vertex.Format.Attr.Type.Enum.Float4:
                    return nameof(VertexElementFormat.Vector4);

                case Shader.Vertex.Format.Attr.Type.Enum.UShort4Norm:
                    return nameof(VertexElementFormat.NormalizedShort4);

                case Shader.Vertex.Format.Attr.Type.Enum.UByte4Norm:
                    return nameof(VertexElementFormat.Byte4);
            }
            
            return "Unknown";
        }

        private static string GetVertexElementUsage(Shader.Vertex.Format.Attr.Enum attribute)
        {
            switch (attribute)
            {
                case Shader.Vertex.Format.Attr.Enum.Pos:
                    return $"{nameof(VertexElementUsage.Position)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Color:
                    return $"{nameof(VertexElementUsage.Color)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Tex0:
                    return $"{nameof(VertexElementUsage.TextureCoordinate)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Tex1:
                    return $"{nameof(VertexElementUsage.TextureCoordinate)}, 1";
                case Shader.Vertex.Format.Attr.Enum.Coverage:
                    return $"{nameof(VertexElementUsage.Normal)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Rect:
                    return $"{nameof(VertexElementUsage.Binormal)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Tile:
                    return $"{nameof(VertexElementUsage.Tangent)}, 0";
                case Shader.Vertex.Format.Attr.Enum.ImagePos:
                    return $"{nameof(VertexElementUsage.Normal)}, 0";
                default:
                    return "Unknown";
            }
        }
    }
}
